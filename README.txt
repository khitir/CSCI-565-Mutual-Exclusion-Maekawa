Python version: 3.11.5

This project implements Maekawa's Mutual Exclusion Algorithm using Python, which provides a decentralized mechanism for achieving mutual exclusion in a distributed system. The algorithm is designed around quorum-based voting and uses vector clocks to maintain the causal order of events between processes. The implementation consists of two main components: vector clocks and Maekawa's mutual exclusion logic. The VectorClock class keeps track of the logical clock for each process, ensuring that each process’s clock is incremented whenever an event occurs, and the clock is updated based on the vector timestamps received from other processes. The MaekawaMutex class implements the core of Maekawa’s algorithm, which involves sending requests to a subset of processes (the voting group or quorum) and receiving "OK" votes from them before entering the critical section. The algorithm ensures that only one process can enter the critical section at any given time, and it manages the release of locks and allows queued requests to proceed in the order they are received.

The key files in this project include distributed_mutex.py, which contains the full implementation of the algorithm, and main.py, which acts as the entry point to initialize and run the processes. The system operates over a network using sockets, where each process has a unique ID and communicates with other processes via their IP addresses and assigned ports. The project assumes that the number of processes is fixed and known in advance, and each process starts with knowledge of its own process ID, the total number of processes, and the addresses of the other processes. The vector clock ensures the correct causal order of events, and the processes communicate by sending "REQUEST," "OK," and "RELEASE" messages. The code ensures that vector clocks are updated correctly on every message send and receive operation, and logs are printed to the console to show the current state of the vector clock and the votes received. Each process waits for a sufficient number of "OK" responses from its quorum before it can enter the critical section, thus maintaining mutual exclusion.

To run the project, Python 3.x is required. The code assumes that all machines or virtual machines running the processes can communicate over the specified IP addresses and ports. To start the system, clone or download the project files and run main.py from the terminal for each process, entering the appropriate process ID when prompted. Each process is initialized with its ID, number of processes, and hosts’ IP addresses, and then waits for input to request the lock. The processes will request the critical section by sending "REQUEST" messages to the other members of their quorum, wait for "OK" votes, and once they have received enough votes, they will enter and exit the critical section. After completing the critical section, the process releases the lock and allows other processes to proceed by sending "RELEASE" messages.

The system can be tested by running two or more processes, each in a separate terminal or machine. After requesting and acquiring the lock, the process will output logs indicating the number of votes received and when it enters and exits the critical section. The system ensures that mutual exclusion is maintained and that no two processes can enter the critical section simultaneously. After testing, the processes can be terminated by pressing "Enter" to exit. Additionally, the quorum voting groups are generated dynamically using a grid-based structure, as described in Maekawa's paper. The project can be easily tested by running multiple processes, ensuring mutual exclusion, and verifying that the vector clocks are updated correctly for all events.